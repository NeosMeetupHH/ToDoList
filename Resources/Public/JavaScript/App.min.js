(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _qwest = require('qwest');

var _qwest2 = _interopRequireDefault(_qwest);

var ToDoListApi = (function () {
    function ToDoListApi(endpointUri) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        _classCallCheck(this, ToDoListApi);

        this.endpointUri = endpointUri;
        this.list = context.list || null;
        this.item = context.item || null;
    }

    _createClass(ToDoListApi, [{
        key: 'add',
        value: function add(label) {
            if (!this.list) {
                throw new Error('You cannot use add in this context. Please specify a list.');
            }

            return _qwest2['default'].post(this.endpointUri + 'add', {
                list: this.list,
                label: label
            });
        }
    }, {
        key: 'update',
        value: function update(label) {
            if (!this.item) {
                throw new Error('You cannot use update in this context. Please specify an item.');
            }

            return _qwest2['default'].post(this.endpointUri + 'add', {
                item: this.item,
                label: label
            });
        }
    }, {
        key: 'remove',
        value: function remove() {
            if (!this.item) {
                throw new Error('You cannot use remove in this context. Please specify an item.');
            }

            return _qwest2['default'].post(this.endpointUri + 'remove', {
                item: this.item
            });
        }
    }, {
        key: 'markAsDone',
        value: function markAsDone() {
            if (!this.item) {
                throw new Error('You cannot use markAsDone in this context. Please specify an item.');
            }

            return _qwest2['default'].post(this.endpointUri + 'do', {
                item: this.item
            });
        }
    }, {
        key: 'markAsUnDone',
        value: function markAsUnDone() {
            if (!this.item) {
                throw new Error('You cannot use markAsUnDone in this context. Please specify an item.');
            }

            return _qwest2['default'].post(this.endpointUri + 'undo', {
                item: this.item
            });
        }
    }]);

    return ToDoListApi;
})();

exports['default'] = ToDoListApi;
module.exports = exports['default'];

},{"qwest":8}],2:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _reductAssembler = require('@reduct/assembler');

var _reductAssembler2 = _interopRequireDefault(_reductAssembler);

// Components

var _ComponentsListList = require('./Components/List/List');

var _ComponentsListList2 = _interopRequireDefault(_ComponentsListList);

// Instantiate components all over the dom
var app = (0, _reductAssembler2['default'])();

app.register(_ComponentsListList2['default']);

app.run();

},{"./Components/List/List":4,"@reduct/assembler":5}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _reductComponent = require('@reduct/component');

var _ApiToDoListApi = require('../../Api/ToDoListApi');

var _ApiToDoListApi2 = _interopRequireDefault(_ApiToDoListApi);

var schema = {
    'id': _reductComponent.propTypes.isString.isRequired,
    'isDone': _reductComponent.propTypes.isBoolean.isRequired,
    'endpoint': _reductComponent.propTypes.isString.isRequired
};

var Item = (function (_Component) {
    _inherits(Item, _Component);

    function Item(el) {
        _classCallCheck(this, Item);

        _get(Object.getPrototypeOf(Item.prototype), 'constructor', this).call(this, el, {
            props: el.dataset,
            propTypes: schema
        });

        this.setState('isDone', this.getProp('isDone'));

        this.api = new _ApiToDoListApi2['default'](this.getProp('endpoint'), {
            item: this.getProp('id')
        });

        this.dom = {
            actionRemove: this.el.querySelector('[data-action="remove"]'),
            actionToggleState: this.el.querySelector('[data-action="toggleState"]')
        };

        this.removeItem = this.removeItem.bind(this);
        this.dom.actionRemove.addEventListener('click', this.removeItem);

        this.toggleState = this.toggleState.bind(this);
        this.dom.actionToggleState.addEventListener('click', this.toggleState);

        this.render = this.render.bind(this);
    }

    _createClass(Item, [{
        key: 'removeItem',
        value: function removeItem(e) {
            var _this = this;

            this.api.remove().then(function (xhr, result) {
                if (result.type === 'success:remove') {
                    _this.el.remove();
                    _this.el = null;
                    return;
                }

                throw result;
            })['catch'](function (err) {
                return console.error(err);
            });;
        }
    }, {
        key: 'toggleState',
        value: function toggleState(e) {
            var _this2 = this;

            e.preventDefault();
            var op = this.getState('isDone') ? 'markAsUnDone' : 'markAsDone';

            this.api[op]().then(function (xhr, result) {
                if (result.type.startsWith('success')) {
                    _this2.setState('isDone', !_this2.getState('isDone'));
                    return;
                }

                throw result;
            }).then(this.render)['catch'](function (err) {
                return console.error(err);
            });

            return false;
        }
    }, {
        key: 'render',
        value: function render() {
            this.dom.actionToggleState.checked = this.getState('isDone');
        }
    }]);

    return Item;
})(_reductComponent.Component);

exports['default'] = Item;
module.exports = exports['default'];

},{"../../Api/ToDoListApi":1,"@reduct/component":6}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _reductComponent = require('@reduct/component');

var _ItemItem = require('../Item/Item');

var _ItemItem2 = _interopRequireDefault(_ItemItem);

var _ApiToDoListApi = require('../../Api/ToDoListApi');

var _ApiToDoListApi2 = _interopRequireDefault(_ApiToDoListApi);

var schema = {
    'id': _reductComponent.propTypes.isString.isRequired,
    'endpoint': _reductComponent.propTypes.isString.isRequired
};

function _convertApiResultToDOMNode(xhr, result) {
    if (result.type.startsWith('success')) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(result.view, "text/html");
        var newItem = doc.querySelector('body > *');

        return newItem;
    }

    console.error(result);
}

function _initializeListItem(itemNode) {
    return new _ItemItem2['default'](itemNode);
}

var List = (function (_Component) {
    _inherits(List, _Component);

    function List(el) {
        var _this = this;

        _classCallCheck(this, List);

        _get(Object.getPrototypeOf(List.prototype), 'constructor', this).call(this, el, {
            props: el.dataset,
            propTypes: schema
        });

        this.api = new _ApiToDoListApi2['default'](this.getProp('endpoint'), {
            list: this.getProp('id')
        });

        this.dom = {
            inputLabel: this.el.querySelector('[data-input="label"]'),
            list: this.el.querySelector('ul'),

            addItem: function addItem(newItem) {
                _this.dom.list.appendChild(newItem);
                _this.dom.inputLabel.value = '';
                _this.dom.inputLabel.focus();

                return newItem;
            }
        };

        this.addItem = this.addItem.bind(this);
        this.dom.inputLabel.addEventListener('keyup', this.addItem);

        [].slice.call(this.dom.list.querySelectorAll('li')).forEach(_initializeListItem);
    }

    _createClass(List, [{
        key: 'addItem',
        value: function addItem(e) {
            if (e.keyCode === 13) {
                var label = this.dom.inputLabel.value;

                if (label !== '') {
                    this.api.add(label).then(_convertApiResultToDOMNode).then(this.dom.addItem).then(_initializeListItem)['catch'](function (err) {
                        return console.error(err);
                    });
                }
            }
        }
    }]);

    return List;
})(_reductComponent.Component);

exports['default'] = List;
module.exports = exports['default'];

},{"../../Api/ToDoListApi":1,"../Item/Item":3,"@reduct/component":6}],5:[function(require,module,exports){
(function (process,global){
/**
 *
 * @name @reduct/assembler
 * @version 1.0.1
 * @license MIT
 *
 * @author Tyll Weiß <inkdpixels@gmail.com>
 * @author André König <andre.koenig@posteo.de>
 * @author Wilhelm Behncke
 *
 */

"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (factory) {
    var opts = {
        isTestingEnv: process && process.title && !! ~process.title.indexOf('reduct'),
        packageVersion: {
            major: 1,
            minor: 0,
            patch: 1
        }
    };
    var world = this;

    // Check for globals.
    if (typeof window !== "undefined") {
        world = window;
    } else if (typeof global !== "undefined") {
        world = global;
    } else if (typeof self !== "undefined") {
        world = self;
    }

    // Initiate the global reduct object if necessary.
    if (!world.reduct) {
        world.reduct = {};
    }

    // Export the factory with the global and options to all module formats.
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = factory(world, opts);
    } else if (typeof define === "function" && define.amd) {
        define([], function () {
            return factory(world, opts);
        });
    } else {
        world.reduct.assembler = factory(world, opts);
    }
})(function factory(global, factoryOpts) {

    /**
     * The Assembler.
     *
     * An assembler instance acts as the central point of your
     * application. It is responsible for connecting DOM nodes with
     * actual component instances through exposed interfaces. Those
     * interfaces provides the functionality for registering component
     * classes and bootstrapping the whole application.
     *
     * Usage example:
     *
     *     import assembler from 'assembler';
     *
     *     // Importing your actual components
     *     import MyComponent from 'my-component';
     *     import AnotherComponent from 'another-component';
     *
     *     const app = assembler();
     *
     *     app.register(MyComponent);
     *     app.register(AnotherComponent, 'NewsComponent');
     *
     *     // Start the application (will parse the DOM and mount the
     *     // component instances).
     *     app.run();
     *
     */

    var Assembler = (function () {

        /**
         * Initializes the empty component class index
         * and the actual component instance cache.
         *
         */

        function Assembler() {
            var opts = arguments.length <= 0 || arguments[0] === undefined ? { marker: 'component' } : arguments[0];

            _classCallCheck(this, Assembler);

            this.marker = opts.marker;
            this.selector = "data-" + this.marker;

            this.index = {};

            //
            // The actual instantiated components.
            //
            // Structure:
            //
            //     {
            //         'ComponentClassName': [object, object],
            //         'YetAnotherComponentClassName': [object]
            //     }
            //
            this.components = {};

            //
            // A cache of DOM elements.
            //
            // This is for checking if a component has already been instantiated.
            //
            // TODO: Refactoring: Find another way (with good performance) to combine this
            // array with the `components` object.
            //
            this.elements = [];
        }

        //
        // Create the `assembler` factory function.
        // This factory will create a new instance of the `assembler` and exposes the API
        //

        /**
         * @private
         *
         * Checks if a component has already been instantiated.
         *
         * @param {DOMElement} element The element which should be connected to a component.
         *
         * @returns {boolean}
         *
         */

        _createClass(Assembler, [{
            key: "isInstantiated",
            value: function isInstantiated(element) {
                return !! ~this.elements.indexOf(element);
            }

            /**
             * @private
             *
             * Instantiates a component by a given DOM node.
             *
             * Will extract the component's name out of the DOM nodes `data`
             * attribute, instantiates the actual component object and pushes
             * the instance to the internal `components` index.
             *
             * @param {HTMLElement} element The component's root DOM node.
             *
             */
        }, {
            key: "instantiate",
            value: function instantiate(element) {
                if (!this.isInstantiated(element)) {
                    var _name = element.getAttribute(this.selector);

                    var components = this.components[_name] = [].slice.call(this.components[_name] || []);
                    var Component = this.index[_name];

                    this.elements.unshift(element);

                    components.unshift(new Component(element));
                }
            }

            /**
             * Registers a component class.
             *
             * Usage example
             *
             *     app.register(MyComponent); // Name: 'MyComponent'
             *
             *     app.register(MyComponent, 'FooComponent'); // Name: 'FooComponent'
             *
             * @param {Function} ComponentClass The component class which should be registered.
             * @param {string} name An alternative name (optional)
             *
             */
        }, {
            key: "register",
            value: function register(ComponentClass, name) {
                var type = typeof ComponentClass;

                if (type !== 'function') {
                    throw new Error("'" + type + "' is not a valid component class.");
                }

                name = name || ComponentClass.name;

                this.index[name] = ComponentClass;
            }

            /**
             * Takes a hashmap with multiple component classes
             * and registers them at once.
             *
             * Usage example:
             *
             *     app.registerAll({
             *         MyComponent: MyComponent,        // name: 'MyComponent'
             *         'AnotherComponent': FooComponent // name: 'AnotherComponent'
             *     });
             *
             *     // With destructuring
             *     app.registerAll({MyComponent, FooComponent});
             *
             * @param {object} classMap A map with multiple component classes.
             *
             */
        }, {
            key: "registerAll",
            value: function registerAll(classMap) {
                var _this = this;

                Object.keys(classMap).forEach(function (name) {
                    return _this.register(classMap[name], name);
                });
            }

            /**
             * "Parse" the DOM for component declarations and
             * instantiate the actual, well, components.
             *
             */
        }, {
            key: "run",
            value: function run() {
                var _this2 = this;

                var elements = [].slice.call(document.querySelectorAll("[" + this.selector + "]"));
                var names = Object.keys(this.index);

                //
                // Find all instantiable elements.
                // Note: `getAttribute` has to be used due to: https://github.com/tmpvar/jsdom/issues/961
                //
                elements.filter(function (element) {
                    return !! ~names.indexOf(element.getAttribute(_this2.selector));
                }).forEach(function (element) {
                    return _this2.instantiate(element);
                });
            }
        }]);

        return Assembler;
    })();

    var assembler = function assembler(opts) {
        var assembler = new Assembler(opts);

        //
        // Shard the actual front-facing API (for not leaking private methods and properties).
        //
        var api = {
            register: function register(ComponentClass, name) {
                return assembler.register(ComponentClass, name);
            },
            registerAll: function registerAll(classMap) {
                return assembler.registerAll(classMap);
            },
            run: function run() {
                return assembler.run();
            }
        };

        //
        // Expose additional attributes for the tests.
        //
        if (factoryOpts.isTestingEnv) {
            api.index = assembler.index;
            api.components = assembler.components;
        }

        return api;
    };

    //
    // Add the version information to the factory function.
    //
    assembler.version = factoryOpts.packageVersion;

    return assembler;
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":7}],6:[function(require,module,exports){
(function (process,global){
/**
 *
 * @name @reduct/component
 * @version 1.0.6
 * @license MIT
 *
 * @author Tyll Weiß <inkdpixels@gmail.com>
 * @author André König <andre.koenig@posteo.de>
 * @author Wilhelm Behncke
 *
 */

"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (factory) {
    var version = {
        major: 1,
        minor: 0,
        patch: 6
    };
    var world;

    if (typeof window !== "undefined") {
        world = window;
    } else if (typeof global !== "undefined") {
        world = global;
    } else if (typeof self !== "undefined") {
        world = self;
    } else {
        world = this;
    }

    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = factory(world, version);
    } else if (typeof define === "function" && define.amd) {
        define([], function () {
            return factory(world, version);
        });
    } else {
        world.reductComponent = factory(world, version);
    }
})(function factory(global, version) {
    var _this = this,
        _arguments = arguments;

    var messages = {
        noElement: 'No element was specified while creating a instance of a Class. Creating a detached DOM Element instead.',
        extendDeprecate: '@reduct/component.extend() is deprecated since v1.0.7 - Use the native ES6 extend instead.'
    };

    /**
     * @private
     *
     * Checks if the given argument is a function.
     *
     * @param func {*} The argument which will be validated.
     * @returns {boolean}
     *
     */
    function _isFunction(func) {
        return typeof func === 'function';
    }

    /**
     * @private
     *
     * Checks if the given argument is a Number.
     *
     * @param num {*} The argument which will be validated.
     * @returns {boolean}
     *
     */
    function _isNumeric(num) {
        return !isNaN(num);
    }

    /**
     * @private
     *
     * Checks if the given argument is a boolean or a string containing a boolean.
     *
     * @param bol {*} The argument which will be validated.
     * @returns {boolean}
     *
     */
    function _isBoolean(bol) {
        return typeof bol === 'boolean' || bol === 'true' || bol === 'false';
    }

    /**
     * @private
     *
     * Checks if the given argument is a object.
     *
     * @param obj {*} The argument which will be validated.
     * @returns {boolean}
     *
     */
    function _isObject(obj) {
        return typeof obj === 'object';
    }

    /**
     * @private
     *
     * Checks if the given argument is a string.
     *
     * @param str {*} The argument which will be validated.
     * @returns {boolean}
     *
     */
    function _isString(str) {
        return typeof str === 'string';
    }

    /**
     * @private
     *
     * Checks if the given argument is defined and not `null`.
     *
     * @param val {*} The argument which will be validated.
     * @returns {boolean}
     *
     */
    function _isDefined(val) {
        return val !== null && val !== undefined;
    }

    /**
     * Converts a string containing a boolean to a real boolean if necessary.
     * @param val
     * @returns {*}
     * @private
     */
    function _convertStringBoolean(val) {
        if (val === 'false') {
            val = false;
        }

        if (val === 'true') {
            val = true;
        }

        return val;
    }

    var propTypes = {
        /**
         * Represents a general required check against a value.
         *
         * @param propValue {*} The value which will be validated.
         * @param propName {String} The name which will be logged in case of errors.
         * @param el {HTMLElement} The element on which the value was expected on.
         * @returns {{result: boolean, value: *}}
         *
         */
        isRequired: function isRequired(propValue, propName, el) {
            var isPropInProps = _isDefined(propValue);

            if (!isPropInProps) {
                logger.error('The prop "' + propName + '" is required and wasn‘t found on: ', el);
            }

            return {
                result: isPropInProps,
                value: propValue
            };
        },

        /**
         * Represents a general optional check against a value.
         *
         * @param propValue {*} The value which will be validated.
         * @param propName{String} The name which will be logged in case of errors.
         * @param el {HTMLElement} The element on which the value was expected on.
         * @returns {{result: boolean, value: *}}
         *
         */
        isOptional: function isOptional(propValue, propName, el) {
            var isPropInProps = _isDefined(propValue);

            if (!isPropInProps) {
                logger.info('The prop "' + propName + '" is optional and wasn‘t found on: ', el);
            }

            return {
                result: true,
                value: propValue
            };
        },

        isString: {
            /**
             * Extends the general required validator for the type `String`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isRequired: function isRequired(propValue, propName, el) {
                var isString = _isString(propValue);
                var result = true;

                propTypes.isRequired.apply(_this, _arguments);

                if (!isString) {
                    logger.error('The prop "' + propName + '" is not a string. ', el);
                    result = false;
                }

                return {
                    result: result,
                    value: propValue
                };
            },

            /**
             * Extends the general optional validator for the type `String`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isOptional: function isOptional(propValue, propName, el) {
                var isString = _isString(propValue);
                var result = true;

                if (!isString) {
                    logger.error('The prop "' + propName + '" is not a string. ', el);
                    result = false;
                }

                return {
                    result: result,
                    value: propValue
                };
            }
        },

        isBoolean: {
            /**
             * Extends the general required validator for the type `Boolean`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isRequired: function isRequired(propValue, propName, el) {
                var isBoolean = _isBoolean(propValue);
                var result = true;

                propTypes.isRequired.apply(_this, _arguments);

                if (!isBoolean) {
                    logger.error('The prop "' + propName + '" is not a boolean. ', el);
                    result = false;
                }

                propValue = _convertStringBoolean(propValue);

                return {
                    result: result,
                    value: propValue
                };
            },

            /**
             * Extends the general optional validator for the type `Boolean`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isOptional: function isOptional(propValue, propName, el) {
                var isBoolean = _isBoolean(propValue);
                var result = true;

                if (!isBoolean) {
                    logger.error('The prop "' + propName + '" is not a boolean. ', el);
                    result = false;
                }

                propValue = _convertStringBoolean(propValue);

                return {
                    result: result,
                    value: propValue
                };
            }
        },

        isNumber: {
            /**
             * Extends the general required validator for the type `Number`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isRequired: function isRequired(propValue, propName, el) {
                var isNumber = _isNumeric(propValue);
                var result = true;

                // Since The prop is required, check for it's value beforehand.
                propTypes.isRequired.apply(_this, _arguments);

                if (!isNumber) {
                    logger.error('The prop "' + propName + '" is not a number. ', el);
                    result = false;
                } else {
                    propValue = Math.abs(propValue);
                }

                return {
                    result: result,
                    value: propValue
                };
            },

            /**
             * Extends the general optional validator for the type `Number`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isOptional: function isOptional(propValue, propName, el) {
                var isNumber = _isNumeric(propValue);
                var result = true;

                if (propValue && !isNumber) {
                    logger.error('The prop "' + propName + '" is not a number. ', el);
                    result = false;
                }

                propValue = Math.abs(propValue);

                return {
                    result: result,
                    value: _isNumeric(propValue) ? propValue : undefined
                };
            }
        },

        isObject: {
            /**
             * Extends the general required validator for the type `Object`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isRequired: function isRequired(propValue, propName, el) {
                var result = true;
                var isObject = undefined;

                // Since The prop is required, check for it's value beforehand.
                propTypes.isRequired.apply(_this, _arguments);

                // If the passed Property is a string, convert it to a JSON object beforehand.
                try {
                    propValue = JSON.parse(propValue);
                } catch (e) {}

                // Verify the type of the value.
                isObject = _isObject(propValue);

                if (!isObject) {
                    logger.error('The prop "' + propName + '" is not an valid JSON object. ', el);
                    result = false;
                }

                return {
                    result: result,
                    value: propValue
                };
            },

            /**
             * Extends the general optional validator for the type `Object`.
             *
             * @param propValue {*} The value which will be validated.
             * @param propName {String} The name which will be logged in case of errors.
             * @param el {HTMLElement} The element on which the value was expected on.
             * @returns {{result: boolean, value: *}}
             *
             */
            isOptional: function isOptional(propValue, propName, el) {
                var isPropValueDefined = _isDefined(propValue);
                var result = true;
                var isObject = undefined;

                // If the passed Property is a string, convert it to a JSON object beforehand.
                try {
                    propValue = JSON.parse(propValue);
                } catch (e) {}

                // Verify the type of the value.
                isObject = _isObject(propValue);

                if (isPropValueDefined && !isObject) {
                    logger.error('The prop "' + propName + '" is not an valid JSON object. ', el);
                    result = false;
                }

                return {
                    result: result,
                    value: propValue
                };
            }
        }
    };

    var logger = {
        _logLevel: 2,

        /**
         * Adjusts the noise of the logger.
         * 0 => No messages are displayed
         * 1 => Only severe messages are displayed
         * 2 => Every message is displayed
         *
         * @param int {Number} The new log level.
         * @returns {Void}
         *
         */
        setLogLevel: function setLogLevel(int) {
            logger._logLevel = _isNumeric(int) ? int : 2;
        },

        /**
         * Logs a message to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param targetElement {HTMLElement} An optional target element which will be appended to the log.
         * @returns {Void}
         *
         */
        log: function log(message) {
            var targetElement = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (logger._logLevel <= 2) {
                return;
            }

            try {
                console.log('@reduct/component: ' + message, targetElement);
            } catch (e) {}
        },

        /**
         * Logs a info to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param targetElement {HTMLElement} An optional target element which will be appended to the info.
         * @returns {Void}
         *
         */
        info: function info(message) {
            var targetElement = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (logger._logLevel <= 2) {
                return;
            }

            try {
                console.info('@reduct/component Info: ' + message, targetElement);
            } catch (e) {}
        },

        /**
         * Logs a warning to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param targetElement {HTMLElement} An optional target element which will be appended to the warning.
         * @returns {Void}
         *
         */
        warn: function warn(message) {
            var targetElement = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (logger._logLevel <= 1) {
                return;
            }

            try {
                console.warn('@reduct/component Warning: ' + message, targetElement);
            } catch (e) {}
        },

        /**
         * Logs a error to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param targetElement {HTMLElement} An optional target element which will be appended to the error.
         * @returns {Void}
         *
         */
        error: function error(message) {
            var targetElement = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (logger._logLevel <= 0) {
                return;
            }

            try {
                // We still need the console.error call since the Error object can't print out references to HTML Elements.
                console.error(message, targetElement);
            } catch (e) {}

            throw new Error('@reduct/component Error: Details are posted above.');
        }
    };

    //
    // Reduce the logging noise for the unit tests.
    //
    if (process && process.title && !! ~process.title.indexOf('reduct')) {
        logger.setLogLevel(0);
    }

    /**
     * Helper function to move passed props via constructor into the component
     * instance and validate them along the way
     *
     * @param {Component} component The component instance
     * @param {Object} propTypes A map of propTypes
     * @returns {Void}
     */
    function _validateAndSetProps(component, propTypes) {
        var el = component.el;
        var _passedProps = component._passedProps;
        var _defaultProps = component.getDefaultProps();
        var defaultProps = _isObject(_defaultProps) ? _defaultProps : {};

        for (var propName in propTypes) {
            var propValue = _passedProps[propName] || el.getAttribute('data-' + propName.toLowerCase()) || defaultProps[propName];
            var validator = propTypes[propName];
            var validatorResults = validator(propValue, propName, el);

            if (validatorResults.result) {
                component.props[propName] = validatorResults.value;
            }
        }

        // Freeze the props object to avoid further editing off the object.
        component.props = Object.freeze(component.props);
    }

    /**
     * Helper function to set initial state variables in the component
     * instance
     *
     * @param {Component} component The component instance
     * @returns {Void}
     */
    function _setInitialStates(component) {
        var _initialStates = component.getInitialStates();
        var initialStates = _isObject(_initialStates) ? _initialStates : {};

        for (var stateKey in initialStates) {
            var value = initialStates[stateKey];

            component.setState(stateKey, value);
        }
    }

    var Component = (function () {
        function Component(element, opts) {
            _classCallCheck(this, Component);

            // Fail-Safe mechanism if someone is passing an array or the like as a second argument.
            opts = _isObject(opts) ? opts : {};

            if (!_isDefined(element)) {
                logger.warn(messages.noElement);
            }

            this._passedProps = opts.props || {};
            this.props = {};
            this.states = {};
            this.observers = {};
            this.el = element || global.document.createElement('div');

            _validateAndSetProps(this, opts.propTypes);
            _setInitialStates(this);
        }

        /**
         * Returns the HTML Element on which the Component was mounted upon.
         *
         * @returns {HTMLElement}
         *
         */

        _createClass(Component, [{
            key: "getElement",
            value: function getElement() {
                return this.el;
            }

            /**
             * The default method which declares the default properties of the Component.
             *
             * @returns {Object} The object containing default props.
             *
             */
        }, {
            key: "getDefaultProps",
            value: function getDefaultProps() {
                return {};
            }

            /**
             * Returns the property for the given name.
             *
             * @param propName {String} The name of the property.
             * @returns {*} The value of the property.
             *
             */
        }, {
            key: "getProp",
            value: function getProp(propName) {
                return this.props[propName];
            }

            /**
             * Returns a boolean regarding the existence of the property.
             *
             * @param propName {String} The name of the property.
             * @returns {boolean} The result of the check.
             *
             */
        }, {
            key: "hasProp",
            value: function hasProp(propName) {
                return _isDefined(this.props[propName]);
            }

            /**
             * The default method which declares the default state of the Component.
             *
             * @returns {Object} The object containing default state.
             *
             */
        }, {
            key: "getInitialStates",
            value: function getInitialStates() {
                return {};
            }

            /**
             * Sets a property to the Component.
             *
             * @param stateName {String} The name under which the value will be saved under.
             * @param stateVal {*} The value of the property.
             *
             */
        }, {
            key: "setState",
            value: function setState(stateName, stateVal) {
                var payload = {
                    key: stateName,
                    value: stateVal
                };

                this.states[stateName] = stateVal;

                // Trigger events
                this.trigger('change', payload);
                this.trigger('change:' + stateName, payload);
            }

            /**
             * Returns the property for the given name.
             *
             * @param stateName {String} The name of the property.
             * @returns {*} The value of the property.
             *
             */
        }, {
            key: "getState",
            value: function getState(stateName) {
                return this.states[stateName];
            }

            /**
             * Declares a event listener on the given event name.
             *
             * @param event {String} The name of the event under which the listener will be saved under.
             * @param listener {Function} The listener which will be executed once the event will be fired.
             * @returns {Number} The length of the event listener array.
             *
             */
        }, {
            key: "on",
            value: function on(event, listener) {
                var targetArray = this.observers[event] || (this.observers[event] = []);

                return targetArray.push(listener);
            }

            /**
             * Triggers the event of the given name with optional data.
             *
             * @todo Support for multiple arguments.
             * @param event {String} The name of the event to trigger.
             * @param data {*} The data to pass to all listeners.
             *
             */
        }, {
            key: "trigger",
            value: function trigger(event, data) {
                var value = undefined;
                var key = undefined;

                for (value = this.observers[event], key = 0; value && key < value.length;) {
                    value[key++](data);
                }
            }

            /**
             * Removes the given listener function from the event of the given name.
             * @param event {String} Name of the event.
             * @param listener {Function} The listener function to remove.
             */
        }, {
            key: "off",
            value: function off(event, listener) {
                var value = undefined;
                var key = undefined;

                for (value = this.observers[event] || []; listener && (key = value.indexOf(listener)) > -1;) {
                    value.splice(key, 1);
                }

                this.observers[event] = listener ? value : [];
            }

            /**
             * Extends the Components prototype.
             *
             * @deprecated since version 1.1.0
             */
        }, {
            key: "extend",
            value: function extend() {
                logger.error(messages.extendDeprecate);
            }
        }]);

        return Component;
    })();

    return {
        Component: Component,
        propTypes: propTypes,
        version: version
    };
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":7}],7:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
(function (process){
!function(e){"use strict";var t=function(e){var t=function(e,t,n){n="function"==typeof n?n():null===n?"":void 0===n?"":n,e[e.length]=encodeURIComponent(t)+"="+encodeURIComponent(n)},n=function(e,o,s){var r,i,a;if("[object Array]"===Object.prototype.toString.call(o))for(r=0,i=o.length;i>r;r++)n(e+"["+("object"==typeof o[r]?r:"")+"]",o[r],s);else if(o&&"[object Object]"===o.toString())for(a in o)o.hasOwnProperty(a)&&(e?n(e+"["+a+"]",o[a],s,t):n(a,o[a],s,t));else if(e)t(s,e,o);else for(a in o)t(s,a,o[a]);return s};return n("",e,[]).join("&").replace(/%20/g,"+")};"object"==typeof module&&"object"==typeof module.exports?module.exports=t:"function"==typeof define&&define.amd?define([],function(){return t}):e.param=t}(this),function(e){function t(e){return"function"==typeof e}function n(e){return"object"==typeof e}function o(e){"undefined"!=typeof setImmediate?setImmediate(e):"undefined"!=typeof process&&process.nextTick?process.nextTick(e):setTimeout(e,0)}var s;e[0][e[1]]=function r(e){var i,a=[],p=[],c=function(e,t){return null==i&&null!=e&&(i=e,a=t,p.length&&o(function(){for(var e=0;e<p.length;e++)p[e]()})),i};return c.then=function(c,d){var u=r(e),m=function(){function e(o){var r,i=0;try{if(o&&(n(o)||t(o))&&t(r=o.then)){if(o===u)throw new TypeError;r.call(o,function(){i++||e.apply(s,arguments)},function(e){i++||u(!1,[e])})}else u(!0,arguments)}catch(a){i++||u(!1,[a])}}try{var o=i?c:d;t(o)?e(o.apply(s,a||[])):u(i,a)}catch(r){u(!1,[r])}};return null!=i?o(m):p.push(m),u},e&&(c=e(c)),c}}("undefined"==typeof module?[window,"pinkySwear"]:[module,"exports"]),function(e,t,n){"undefined"!=typeof module&&module.exports?module.exports=n:"function"==typeof define&&define.amd?define(n):e[t]=n}(this,"qwest",function(){var win=window,doc=document,defaultXdrResponseType="json",limit=null,requests=0,request_stack=[],getXHR=function(){return win.XMLHttpRequest?new win.XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP")},xhr2=""===getXHR().responseType,qwest=function(method,url,data,options,before){method=method.toUpperCase(),data=data||null,options=options||{};var nativeResponseParsing=!1,crossOrigin,xhr,xdr=!1,timeoutInterval,aborted=!1,attempts=0,headers={},mimeTypes={text:"*/*",xml:"text/xml",json:"application/json",post:"application/x-www-form-urlencoded"},accept={text:"*/*",xml:"application/xml; q=1.0, text/xml; q=0.8, */*; q=0.1",json:"application/json; q=1.0, text/*; q=0.8, */*; q=0.1"},contentType="Content-Type",vars="",i,j,serialized,response,sending=!1,delayed=!1,timeout_start,promise=require("pinkyswear")(function(e){return e["catch"]=function(t){return e.then(null,t)},e.complete=function(t){return e.then(t,t)},e.send=function(){if(!sending){if(sending=!0,limit&&++requests==limit)return void request_stack.push(e);if(timeout_start=Date.now(),xhr=getXHR(),crossOrigin&&("withCredentials"in xhr||!win.XDomainRequest||(xhr=new XDomainRequest,xdr=!0,"GET"!=method&&"POST"!=method&&(method="POST"))),xdr?xhr.open(method,url):(xhr.open(method,url,options.async,options.user,options.password),xhr2&&options.async&&(xhr.withCredentials=options.withCredentials)),!xdr)for(var t in headers)xhr.setRequestHeader(t,headers[t]);if(xhr2&&"document"!=options.responseType&&"auto"!=options.responseType)try{xhr.responseType=options.responseType,nativeResponseParsing=xhr.responseType==options.responseType}catch(n){}xhr2||xdr?(xhr.onload=handleResponse,xhr.onerror=handleError):xhr.onreadystatechange=function(){4==xhr.readyState&&handleResponse()},"auto"!=options.responseType&&"overrideMimeType"in xhr&&xhr.overrideMimeType(mimeTypes[options.responseType]),before&&before(xhr),xdr?setTimeout(function(){xhr.send("GET"!=method?data:null)},0):xhr.send("GET"!=method?data:null)}},e}),handleResponse=function(){var i,responseType;if(--requests,sending=!1,Date.now()-timeout_start>=options.timeout)return void(options.attempts&&++attempts==options.attempts?promise(!1,[xhr,response,new Error("Timeout ("+url+")")]):promise.send());request_stack.length&&request_stack.shift().send();try{if(nativeResponseParsing&&"response"in xhr&&null!==xhr.response)response=xhr.response;else if("document"==options.responseType){var frame=doc.createElement("iframe");frame.style.display="none",doc.body.appendChild(frame),frame.contentDocument.open(),frame.contentDocument.write(xhr.response),frame.contentDocument.close(),response=frame.contentDocument,doc.body.removeChild(frame)}else{if(responseType=options.responseType,"auto"==responseType)if(xdr)responseType=defaultXdrResponseType;else{var ct=xhr.getResponseHeader(contentType)||"";responseType=ct.indexOf(mimeTypes.json)>-1?"json":ct.indexOf(mimeTypes.xml)>-1?"xml":"text"}switch(responseType){case"json":try{response="JSON"in win?JSON.parse(xhr.responseText):eval("("+xhr.responseText+")")}catch(e){throw"Error while parsing JSON body : "+e}break;case"xml":try{win.DOMParser?response=(new DOMParser).parseFromString(xhr.responseText,"text/xml"):(response=new ActiveXObject("Microsoft.XMLDOM"),response.async="false",response.loadXML(xhr.responseText))}catch(e){response=void 0}if(!response||!response.documentElement||response.getElementsByTagName("parsererror").length)throw"Invalid XML";break;default:response=xhr.responseText}}if("status"in xhr&&!/^2|1223/.test(xhr.status))throw xhr.status+" ("+xhr.statusText+")";promise(!0,[xhr,response])}catch(e){promise(!1,[xhr,response,e])}},handleError=function(e){--requests,promise(!1,[xhr,null,new Error("Connection aborted")])};switch(options.async="async"in options?!!options.async:!0,options.cache="cache"in options?!!options.cache:"GET"!=method,options.dataType="dataType"in options?options.dataType.toLowerCase():"post",options.responseType="responseType"in options?options.responseType.toLowerCase():"auto",options.user=options.user||"",options.password=options.password||"",options.withCredentials=!!options.withCredentials,options.timeout="timeout"in options?parseInt(options.timeout,10):3e4,options.attempts="attempts"in options?parseInt(options.attempts,10):1,i=url.match(/\/\/(.+?)\//),crossOrigin=i&&(i[1]?i[1]!=location.host:!1),"ArrayBuffer"in win&&data instanceof ArrayBuffer?options.dataType="arraybuffer":"Blob"in win&&data instanceof Blob?options.dataType="blob":"Document"in win&&data instanceof Document?options.dataType="document":"FormData"in win&&data instanceof FormData&&(options.dataType="formdata"),options.dataType){case"json":data=JSON.stringify(data);break;case"post":data=require("jquery-param")(data)}if(options.headers){var format=function(e,t,n){return t+n.toUpperCase()};for(i in options.headers)headers[i.replace(/(^|-)([^-])/g,format)]=options.headers[i]}return headers[contentType]||"GET"==method||options.dataType in mimeTypes&&mimeTypes[options.dataType]&&(headers[contentType]=mimeTypes[options.dataType]),headers.Accept||(headers.Accept=options.responseType in accept?accept[options.responseType]:"*/*"),crossOrigin||headers["X-Requested-With"]||(headers["X-Requested-With"]="XMLHttpRequest"),"GET"==method&&data&&(vars+=data),options.cache||(vars&&(vars+="&"),vars+="__t="+ +new Date),vars&&(url+=(/\?/.test(url)?"&":"?")+vars),options.async&&promise.send(),promise};return{base:"",get:function(e,t,n,o){return qwest("GET",this.base+e,t,n,o)},post:function(e,t,n,o){return qwest("POST",this.base+e,t,n,o)},put:function(e,t,n,o){return qwest("PUT",this.base+e,t,n,o)},"delete":function(e,t,n,o){return qwest("DELETE",this.base+e,t,n,o)},map:function(e,t,n,o,s){return qwest(e.toUpperCase(),this.base+t,n,o,s)},xhr2:xhr2,limit:function(e){limit=e},setDefaultXdrResponseType:function(e){defaultXdrResponseType=e.toLowerCase()}}}());
}).call(this,require('_process'))
},{"_process":7,"jquery-param":9,"pinkyswear":10}],9:[function(require,module,exports){
/**
 * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT
 */
/*global define */
(function (global) {
    'use strict';

    var param = function (a) {
        var add = function (s, k, v) {
            v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;
            s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);
        }, buildParams = function (prefix, obj, s) {
            var i, len, key;

            if (Object.prototype.toString.call(obj) === '[object Array]') {
                for (i = 0, len = obj.length; i < len; i++) {
                    buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i], s);
                }
            } else if (obj && obj.toString() === '[object Object]') {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (prefix) {
                            buildParams(prefix + '[' + key + ']', obj[key], s, add);
                        } else {
                            buildParams(key, obj[key], s, add);
                        }
                    }
                }
            } else if (prefix) {
                add(s, prefix, obj);
            } else {
                for (key in obj) {
                    add(s, key, obj[key]);
                }
            }
            return s;
        };
        return buildParams('', a, []).join('&').replace(/%20/g, '+');
    };

    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = param;
    } else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return param;
        });
    } else {
        global.param = param;
    }

}(this));

},{}],10:[function(require,module,exports){
(function (process){
/*
 * PinkySwear.js 2.2.2 - Minimalistic implementation of the Promises/A+ spec
 * 
 * Public Domain. Use, modify and distribute it any way you like. No attribution required.
 *
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 *
 * PinkySwear is a very small implementation of the Promises/A+ specification. After compilation with the
 * Google Closure Compiler and gzipping it weighs less than 500 bytes. It is based on the implementation for 
 * Minified.js and should be perfect for embedding. 
 *
 *
 * PinkySwear has just three functions.
 *
 * To create a new promise in pending state, call pinkySwear():
 *         var promise = pinkySwear();
 *
 * The returned object has a Promises/A+ compatible then() implementation:
 *          promise.then(function(value) { alert("Success!"); }, function(value) { alert("Failure!"); });
 *
 *
 * The promise returned by pinkySwear() is a function. To fulfill the promise, call the function with true as first argument and
 * an optional array of values to pass to the then() handler. By putting more than one value in the array, you can pass more than one
 * value to the then() handlers. Here an example to fulfill a promsise, this time with only one argument: 
 *         promise(true, [42]);
 *
 * When the promise has been rejected, call it with false. Again, there may be more than one argument for the then() handler:
 *         promise(true, [6, 6, 6]);
 *         
 * You can obtain the promise's current state by calling the function without arguments. It will be true if fulfilled,
 * false if rejected, and otherwise undefined.
 * 		   var state = promise(); 
 * 
 * https://github.com/timjansen/PinkySwear.js
 */
(function(target) {
	var undef;

	function isFunction(f) {
		return typeof f == 'function';
	}
	function isObject(f) {
		return typeof f == 'object';
	}
	function defer(callback) {
		if (typeof setImmediate != 'undefined')
			setImmediate(callback);
		else if (typeof process != 'undefined' && process['nextTick'])
			process['nextTick'](callback);
		else
			setTimeout(callback, 0);
	}

	target[0][target[1]] = function pinkySwear(extend) {
		var state;           // undefined/null = pending, true = fulfilled, false = rejected
		var values = [];     // an array of values as arguments for the then() handlers
		var deferred = [];   // functions to call when set() is invoked

		var set = function(newState, newValues) {
			if (state == null && newState != null) {
				state = newState;
				values = newValues;
				if (deferred.length)
					defer(function() {
						for (var i = 0; i < deferred.length; i++)
							deferred[i]();
					});
			}
			return state;
		};

		set['then'] = function (onFulfilled, onRejected) {
			var promise2 = pinkySwear(extend);
			var callCallbacks = function() {
	    		try {
	    			var f = (state ? onFulfilled : onRejected);
	    			if (isFunction(f)) {
		   				function resolve(x) {
						    var then, cbCalled = 0;
		   					try {
				   				if (x && (isObject(x) || isFunction(x)) && isFunction(then = x['then'])) {
										if (x === promise2)
											throw new TypeError();
										then['call'](x,
											function() { if (!cbCalled++) resolve.apply(undef,arguments); } ,
											function(value){ if (!cbCalled++) promise2(false,[value]);});
				   				}
				   				else
				   					promise2(true, arguments);
		   					}
		   					catch(e) {
		   						if (!cbCalled++)
		   							promise2(false, [e]);
		   					}
		   				}
		   				resolve(f.apply(undef, values || []));
		   			}
		   			else
		   				promise2(state, values);
				}
				catch (e) {
					promise2(false, [e]);
				}
			};
			if (state != null)
				defer(callCallbacks);
			else
				deferred.push(callCallbacks);
			return promise2;
		};
        if(extend){
            set = extend(set);
        }
		return set;
	};
})(typeof module == 'undefined' ? [window, 'pinkySwear'] : [module, 'exports']);


}).call(this,require('_process'))
},{"_process":7}]},{},[2]);
